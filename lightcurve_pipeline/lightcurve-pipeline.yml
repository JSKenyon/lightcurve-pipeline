#!/usr/bin/env -S stimela run

_include:
  - lightcurve-cabs.yml
  - (breifast.cabs)breifast.yml
  - (breifast.cabs)tron-cabs.yml
  - (breifast)tron-breifast.yml
  - (breifast)tron-lightcurves.yml

## this augments the standard 'opts' config section to tweak logging settings
opts:
  log:
    dir: logs/log-{config.run.datetime}
    name: log-{info.fqname}
    nest: 2
    symlink: log
  backend:
    select: singularity
    rlimits:
      NOFILE: 100000  # set high limit on number of open files

lightcurve-pipeline:
  name: lightcurve-pipeline
  info: "Generic pipeline for extracting lightcurves from interferometer data."

  assign:
    dir-out: '{recipe.dirs.base}/{recipe.dirs.sub}{recipe.output-suffix}'  # output products go here
    image-prefix: '{recipe.dir-out}/im{info.suffix}{recipe.variant}/im{info.suffix}{recipe.variant}'  # prefix for image names at each step
    log.dir: '{recipe.dir-out}/logs/log-{config.run.datetime}'  # put logs into output dir
    # some more directory assignments
    dirs.temp: "{recipe.dirs.base}/tmp"  # temp files go here
    ms-path: "{recipe.dirs.ms}/{recipe.ms-name}"

    # _chan1x: =recipe.chan1 - 1       # end channel, inclusive -- helper variable to form CASA spw
    casa-spw: 0 #"0:{recipe.chan0}~{recipe._chan1x}"  # CASA spw parameter

    # extra lightcurve suffix, added if convolving
    lc-suffix: =IF(recipe.convolve.arcsec or recipe.convolve.time, "-{recipe.convolve.time:.0f}s-{recipe.convolve.arcsec:.0f}asec", "")

  assign_based_on:
    _include: datasets.yml

  inputs:
    obs:
      choices: [meerkat_uhf_test, ata_test]
      info: "Selects observation, see datasets.yml for list of observations."
      default: ata_test
    output-suffix:
      dtype: str
      default: ''
    variant:
      dtype: str
      default: ''
    htc_cadence:
      dtype: int
      default: 1
    htc_size:
      dtype: int
      default: 512
    htc_scale:
      dtype: str
      default: '{recipe.pixel_scale}'
    htc_weight:
      dtype: str
      default: natural
    convolve:
      arcsec:
        dtype: float
        default: 0
      time:
        dtype: float
        default: 120
    mad_flag:
      dtype: bool
      default: false
      aliases:
        - (quartical).mad_flags.enable
    publish-plots:
      dtype: bool
      default: false
    publish-plot-title:
      default: 'Observation {recipe.obs}: peak $ {{peak_ujy:.0f}}\pm{{peak_std_ujy:.0f}} $ uJy'

  aliases:
    ms:
      - (wsclean).ms
      - (quartical).input_ms.path
    weight:
      - (wsclean).weight
      - (wsclean_pol).weight
    minuv-l:
      - (wsclean).minuv-l
    taper-inner-tukey:
      - (wsclean).taper-inner-tukey

  steps:
    flag-save:
      info: |
        Create a backup of the original flags on the dataset. This step is only
        run when the init tag is selected.
      tags: [init, never]
      cab: casa.flagman
      params:
        ms: =recipe.ms-path
        mode: save
        versionname: =recipe.initial-flag-version

    save-ms-info:
      info: |
        Run some custom python code to extract some useful metadata
        from the dataset
      tags: [always]
      cab: save-ms-info
      skip_if_outputs: exist
      params:
        ms: =recipe.ms-path
        ms-info-file: '{recipe.dir-out}/{recipe.ms-name}.yml'

    ms-info:
      info: |
        Load the file generated by save-ms-info so that it can be used by later
        recipe steps. Note that this step must be run for any subsequent steps
        which use its outputs to work.
      tags: [always]
      cab: load-ms-info
      params:
        ms-info-file: =steps.save-ms-info.ms-info-file

    flag-reset:
      info: |
        Restore the original flags to the dataset. The flag-save step must have
        been run once for this step to work.
      cab: casa.flagman
      params:
        ms: =recipe.ms-path
        mode: restore
        versionname: =recipe.initial-flag-version

    image-1:
      info: |
        Image and deconvolve the data using wsclean. Masking and thresholding
        are handled automatically by wsclean. This may not work in all cases.
      _use: lib.steps.wsclean.image_column
      params:
        column: DATA  # Start from the contents of the DATA column.

    mask-1:
      info: |
        Make a mask for the field using breizorro.
      recipe: make_masks
      params:
        restored-image: "{previous.restored.mfs}"
        prefix: "{previous.prefix}"
        mask: "{current.prefix}-mask.fits"

    flagsummary-1:
      info: |
        Use casa to generate a summary of the flags on the dataset.
      cab: casa.flagsummary
      params:
        ms: =recipe.ms-path
        spw: =recipe.casa-spw

    predict-1:
      info: |
        Use wsclean to write the visibilities associated with the model to the
        MODEL_DATA column.
      _use: lib.steps.wsclean.predict
      params:
        ms: =recipe.ms-path
        prefix: '{steps.image-1.prefix}'
        nchan: '{steps.image-1.nchan}'

    selfcal-1:
      info: |
        Use quartical to perform basic selfcal. Solves for a delay and phase
        term per scan. Note that the selfcal step may require tuning based
        on the field and instrument in question.
      _use: lib.steps.quartical.k

    flagsummary-2:
      info: |
        Use casa to generate a summary of the flags on the dataset.
      cab: casa.flagsummary
      params:
        ms: =recipe.ms-path
        spw: =recipe.casa-spw

    image-2:
      info: |
        Image and deconvolve the selfcal corrected data using wsclean and a
        fits mask.
      _use: lib.steps.wsclean.image_column
      params:
        column: =steps.selfcal-*.corrected_data_column
        fits-mask: =steps.mask-*.mask
        auto-threshold: 1

    predict-2:
      info: |
        Use wsclean to write the visibilities associated with the model to the
        MODEL_DATA column.
      _use: lib.steps.wsclean.predict
      params:
        ms: =recipe.ms-path
        prefix: =steps.image-2.prefix
        nchan: =steps.image-2.nchan

    add-corrected-data:
      info: |
        Use casa to add the CORRECTED_DATA column if it does not exist.
      cab: msutils.addcol
      params:
        msname: =recipe.ms-path
        colname: CORRECTED_DATA

    subtract-model:
      info: |
        Subtract the model visibilities from the corrected data to produce the
        corrected residuals.
      cab: taql.update
      params:
        ms: =recipe.ms-path
        commands: =LIST("set", "CORRECTED_DATA={steps.image-2.column}-MODEL_DATA")

    htc-image-1:
      info: |
        Use wsclean to create a series of images corresponding to time
        intervals. Ideally, this will be an image per unique time, but this
        resolution can be controlled using the htc_cadence parameter to
        decrease computational expense at the cost of time resolution.
      _use: lib.steps.wsclean.dirty
      params:
        column: CORRECTED_DATA
        prefix: =DIRNAME(recipe.image-prefix) + '-cad{recipe.htc_cadence}/images/cad{recipe.htc_cadence}'
        intervals-out: =steps.ms-info.num_intervals / recipe.htc_cadence
        nchan: 1
        niter: 0
        weight: '{recipe.htc_weight}'
        size: '{recipe.htc_size}'
        scale: '{recipe.htc_scale}'
        reorder: true
        no-dirty: true
      tags: [lightcurves]
      skip_if_outputs: fresh

    htc-stack-1:
      info: |
        Stack high time resolution images into a zarr cube.
      cab: breifast.stack-time-cube
      backend:
        select: native
      params:
        images: =steps.htc-image*.restored.per-interval
        cds: =DIRNAME(recipe.image-prefix) + '-cad{recipe.htc_cadence}/cube-{recipe.htc_cadence}.zarr'
        delta-time: =steps.ms-info.delta-time
        obs-label: =recipe.obs
        ra-chunking: 512
        dec-chunking: 512
        time-chunking: 100
      skip_if_outputs: fresh
      tags: [lightcurves]

    cube-mean-to-fits:
      info: |
        Converts time-mean component of zarr cube into FITS image.
      cab: breifast.zarr-to-fits
      backend:
        select: native
      params:
        cds: =steps.htc-stack-*.cds
        out-image: =STRIPEXT(current.cds) + '.mean.fits'
        var: mean
      skip_if_outputs: fresh
      tags: [lightcurves, cubes_to_fits, cubes]

    cube-to-fits:
      info: |
        Converts zarr cube into FITS cube.
      cab: breifast.zarr-to-fits
      backend:
        select: native
      params:
        cds: =steps.htc-stack-*.cds
        out-image: =STRIPEXT(current.cds) + '.fits'
        var: cube
      skip_if_outputs: fresh
      tags: [lightcurves, cubes_to_fits, cubes]

    breifast:
      info: runs a multi-timescale breifast search on cubes
      recipe: tron-breifast
      backend:
        select: native
      params:
        deep-image: =steps.image-2.restored.mfs
        cds: =steps.htc-stack-*.cds
        timescales: [0,30,60,120,240,480]
      tags: [breifast]

    collect-cds-list:
      cab:
        flavour:
          kind: python-code
        inputs:
          cds:
            default: =steps.breifast.cds
          timescales:
            dtype: List[float]
            default: =steps.breifast.timescales
        outputs:
          cds-list:
            dtype: List[Directory]
        command: |
          import os.path
          cds_list = [cds if t == 0 else os.path.splitext(cds)[0] + f"-{int(t)}s.zarr" for t in timescales]
      tags: [lightcurves]

    lightcurves:
      info: runs lightcurve analysis on cubes
      recipe: tron-lightcurves
      backend:
        select: native
      params:
        dir-out: =recipe.dir-out
        image: =steps.breifast.deep-image
        cds-list: =steps.collect-cds-list.cds-list
        ncpu: =recipe.ncpu
        nlc: =recipe.nlc
      tags: [lightcurves]
